/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmory imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmory exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		Object.defineProperty(exports, name, {
/******/ 			configurable: false,
/******/ 			enumerable: true,
/******/ 			get: getter
/******/ 		});
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports) {

eval("/*\n * jQuery Countdown - v1.2.8\n * http://github.com/kemar/jquery.countdown\n * Licensed MIT\n */\n\n(function ($, window, document, undefined) {\n\n    \"use strict\";\n\n    /*\n     * .countDown()\n     *\n     * Description:\n     *      Unobtrusive and easily skinable countdown jQuery plugin.\n     *\n     * Usage:\n     *      $(element).countDown()\n     *\n     *      $(element) is a valid <time> or any other HTML tag containing a text representation of a date/time\n     *      or duration remaining before a deadline expires.\n     *      If $(element) is a <time> tag, the datetime attribute is checked first.\n     *          <time datetime=\"2013-12-13T17:43:00\">Friday, December 13th, 2013 5:43pm</time>\n     *          <time>2012-12-08T14:30:00+0100</time>\n     *          <time>PT01H01M15S</time>\n     *          <h1>600 days, 3:59:12</h1>\n     *\n     *      The text representation of a date/time or duration can be:\n     *      - a valid duration string:\n     *          PT00M10S\n     *          PT01H01M15S\n     *          P2DT20H00M10S\n     *      - a valid global date and time string with its timezone offset:\n     *          2012-12-08T14:30:00.432+0100\n     *          2012-12-08T05:30:00-0800\n     *          2012-12-08T13:30Z\n     *      - a valid time string:\n     *          12:30\n     *          12:30:39\n     *          12:30:39.929\n     *      - a human readable duration string:\n     *          2h 0m\n     *          4h 18m 3s\n     *          24h00m59s\n     *          600 jours, 3:59:12\n     *          600 days, 3:59:12\n     *      - the output of a JavaScript Date.parse() parsable string:\n     *          Date.toDateString() => Sat Dec 20 2014\n     *          Date.toGMTString()  => Sat, 20 Dec 2014 09:24:00 GMT\n     *          Date.toUTCString()  => Sat, 20 Dec 2014 09:24:00 GMT\n     *\n     *      If $(element) is not a <time> tag, a new one is created and appended to $(element).\n     *\n     * Literature, resources and inspiration:\n     *      JavaScript Date reference:\n     *          https://developer.mozilla.org/docs/JavaScript/Reference/Global_Objects/Date\n     *      About the <time> element:\n     *          https://html.spec.whatwg.org/multipage/semantics.html#the-time-element\n     *          http://www.w3.org/TR/html5/text-level-semantics.html#the-time-element\n     *          http://wiki.whatwg.org/wiki/Time_element\n     *      <time> history:\n     *          http://www.brucelawson.co.uk/2012/best-of-time/\n     *          http://www.webmonkey.com/2011/11/w3c-adds-time-element-back-to-html5/\n     *      Formats:\n     *          http://en.wikipedia.org/wiki/ISO_8601\n     *      jQuery plugin syntax:\n     *          https://github.com/jquery-boilerplate/jquery-patterns\n     *          https://github.com/jquery-boilerplate/jquery-boilerplate/wiki/Extending-jQuery-Boilerplate\n     *          http://frederictonug.net/jquery-plugin-development-with-the-jquery-boilerplate\n     *\n     * Example of generated HTML markup:\n     *      <time class=\"countdown\" datetime=\"P12DT05H16M22S\">\n     *          <span class=\"item item-dd\">\n     *              <span class=\"dd\"></span>\n     *              <span class=\"label label-dd\">days</span>\n     *          </span>\n     *          <span class=\"separator separator-dd\">,</span>\n     *          <span class=\"item item-hh\">\n     *              <span class=\"hh-1\"></span>\n     *              <span class=\"hh-2\"></span>\n     *              <span class=\"label label-hh\">hours</span>\n     *          </span>\n     *          <span class=\"separator\">:</span>\n     *          <span class=\"item item-mm\">\n     *              <span class=\"mm-1\"></span>\n     *              <span class=\"mm-2\"></span>\n     *              <span class=\"label label-mm\">minutes</span>\n     *          </span>\n     *          <span class=\"separator\">:</span>\n     *          <span class=\"item item-ss\">\n     *              <span class=\"ss-1\"></span>\n     *              <span class=\"ss-2\"></span>\n     *              <span class=\"label label-ss\">seconds</span>\n     *          </span>\n     *      </time>\n     */\n\n    var pluginName = 'countDown';\n\n    var defaults = {\n        css_class: 'countdown',\n        always_show_days: false,\n        with_labels: true,\n        with_seconds: true,\n        with_separators: true,\n        with_hh_leading_zero: true,\n        with_mm_leading_zero: true,\n        with_ss_leading_zero: true,\n        label_dd: 'days',\n        label_hh: 'hours',\n        label_mm: 'minutes',\n        label_ss: 'seconds',\n        separator: ':',\n        separator_days: ','\n    };\n\n    function CountDown(element, options) {\n        this.element = $(element);\n        this.options = $.extend({}, defaults, options);\n        this._defaults = defaults;\n        this._name = pluginName;\n        this.init();\n    }\n\n    $.extend(CountDown.prototype, {\n\n        init: function () {\n            if (this.element.children().length) {\n                return;\n            }\n            if (this.element.attr('datetime')) {  // Try to parse the datetime attribute first.\n                this.endDate = this.parseEndDate(this.element.attr('datetime'));\n            }\n            if (this.endDate === undefined) {  // Fallback on the text content.\n                this.endDate = this.parseEndDate(this.element.text());\n            }\n            if (this.endDate === undefined) {  // Unable to parse a date.\n                return;\n            }\n            if (this.element.is('time')) {\n                this.timeElement = this.element;\n            } else {\n                this.timeElement = $('<time></time>');\n                this.element.html(this.timeElement);\n            }\n            this.markup();\n            this.setTimeoutDelay = this.sToMs(1);\n            this.daysVisible = true;\n            this.timeElement.on('time.elapsed', this.options.onTimeElapsed);\n            this.timeElement.on('time.tick', this.options.onTick);\n            this.doCountDown();\n        },\n\n        parseEndDate: function (str) {\n\n            var d;\n\n            d = this.parseDuration(str);\n            if (d instanceof Date) {\n                return d;\n            }\n\n            d = this.parseDateTime(str);\n            if (d instanceof Date) {\n                return d;\n            }\n\n            d = this.parseHumanReadableDuration(str);\n            if (d instanceof Date) {\n                return d;\n            }\n\n            // Try to parse a string representation of a date.\n            // https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Date/parse\n            d = Date.parse(str);\n            if (!isNaN(d)) {\n                return new Date(d);\n            }\n\n        },\n\n        // Convert a valid duration string representing a duration to a Date object.\n        //\n        // https://html.spec.whatwg.org/multipage/infrastructure.html#valid-duration-string\n        // http://en.wikipedia.org/wiki/ISO_8601#Durations\n        // i.e.: P2DT20H00M10S, PT01H01M15S, PT00M10S, P2D, P2DT20H00M10.55S\n        //\n        // RegExp:\n        // /^\n        //    P                     => duration designator (historically called \"period\")\n        //    (?:(\\d+)D)?           => (days) followed by the letter \"D\" (optional)\n        //    T?                    => the letter \"T\" that precedes the time components of the representation (optional)\n        //    (?:(\\d+)H)?           => (hours) followed by the letter \"H\" (optional)\n        //    (?:(\\d+)M)?           => (minutes) followed by the letter \"M\" (optional)\n        //    (\n        //         ?:(\\d+)          => (seconds) (optional)\n        //         (?:\\.(\\d{1,3}))? => (milliseconds) full stop character (.) and fractional part of second (optional)\n        //         S                => followed by the letter \"S\"\n        //    )?\n        // $/\n        parseDuration: function (str) {\n            var timeArray = str.match(/^P(?:(\\d+)D)?T?(?:(\\d+)H)?(?:(\\d+)M)?(?:(\\d+)(?:\\.(\\d{1,3}))?S)?$/);\n            if (timeArray) {\n                var d, dd, hh, mm, ss, ms;\n                dd = timeArray[1] ? this.dToMs(timeArray[1]) : 0;\n                hh = timeArray[2] ? this.hToMs(timeArray[2]) : 0;\n                mm = timeArray[3] ? this.mToMs(timeArray[3]) : 0;\n                ss = timeArray[4] ? this.sToMs(timeArray[4]) : 0;\n                ms = timeArray[5] ? parseInt(timeArray[5], 10) : 0;\n                d = new Date();\n                d.setTime(d.getTime() + dd + hh + mm + ss + ms);\n                return d;\n            }\n        },\n\n        // Convert a valid global date and time string to a Date object.\n        // https://html.spec.whatwg.org/multipage/infrastructure.html#valid-global-date-and-time-string\n        //\n        // 2012-12-08T13:30:39+0100\n        //     => [\"2012-12-08T13:30:39+0100\", \"2012\", \"12\", \"08\", \"13\", \"30\", \"39\", undefined, \"+0100\"]\n        // 2012-12-08T06:54-0800\n        //     => [\"2012-12-08T06:54-0800\", \"2012\", \"12\", \"08\", \"06\", \"54\", undefined, undefined, \"-0800\"]\n        // 2012-12-08 13:30Z\n        //     => [\"2012-12-08 13:30Z\", \"2012\", \"12\", \"08\", \"13\", \"30\", undefined, undefined, \"Z\"]\n        // 2013-12-08 06:54:39.929-10:30\n        //     => [\"2013-12-08 06:54:39.929-08:30\", \"2013\", \"12\", \"08\", \"06\", \"54\", \"39\", \"929\", \"-10:30\"]\n        //\n        // RegExp:\n        // ^\n        //     (\\d{4,})         => (year) (four or more ASCII digits)\n        //     -                => hyphen-minus\n        //     (\\d{2})          => (month)\n        //     -                => hyphen-minus\n        //     (\\d{2})          => (day)\n        //     [T\\s]            => T or space\n        //     (\\d{2})          => (hours)\n        //     :                => colon\n        //     (\\d{2})          => (minutes)\n        //     (?:\\:(\\d{2}))?   => colon and (seconds) (optional)\n        //     (?:\\.(\\d{1,3}))? => full stop character (.) and fractional part of second (milliseconds) (optional)\n        //     ([Z\\+\\-\\:\\d]+)?  => time-zone (offset) string (optional)\n        // $\n        parseDateTime: function (str) {\n            var timeArray = str.match(\n                /^(\\d{4,})-(\\d{2})-(\\d{2})[T\\s](\\d{2}):(\\d{2})(?:\\:(\\d{2}))?(?:\\.(\\d{1,3}))?([Z\\+\\-\\:\\d]+)?$/);\n            if (timeArray) {\n\n                // Convert UTC offset from string to milliseconds.\n                // +01:00 => [\"+01:00\", \"+\", \"01\", \"00\"] => -360000\n                // -08:00 => [\"-08:00\", \"-\", \"08\", \"00\"] => 28800000\n                // +05:30 => [\"+05:30\", \"+\", \"05\", \"30\"] => -19800000\n                var offset = timeArray[8] ? timeArray[8].match(/^([\\+\\-])?(\\d{2}):?(\\d{2})$/) : undefined;\n\n                // Time difference between UTC and the given time zone in milliseconds.\n                var utcOffset = 0;\n                if (offset) {\n                    utcOffset = this.hToMs(offset[2]) + this.mToMs(offset[3]);\n                    utcOffset = (offset[1] === '-') ? utcOffset : -utcOffset;\n                }\n\n                var d, yy, mo, dd, hh, mm, ss, ms;\n                yy = timeArray[1];\n                mo = timeArray[2] - 1;\n                dd = timeArray[3];\n                hh = timeArray[4] || 0;\n                mm = timeArray[5] || 0;\n                ss = timeArray[6] || 0;\n                ms = timeArray[7] || 0;\n                d = new Date(Date.UTC(yy, mo, dd, hh, mm, ss, ms));\n\n                d.setTime(d.getTime() + utcOffset);\n\n                return d;\n\n            }\n        },\n\n        // Convert a string representing a human readable duration to a Date object.\n        // Hours and minutes are mandatory.\n        //\n        // 600 days, 3:59:12 => [\"600 days, 3:59:12\", \"600\", \"3\", \"59\", \"12\", undefined]\n        //           3:59:12 => [\"3:59:12\", undefined, \"3\", \"59\", \"12\", undefined]\n        //             00:01 => [\"00:01\", undefined, \"00\", \"01\", undefined, undefined]\n        //          00:00:59 => [\"00:00:59\", undefined, \"00\", \"00\", \"59\", undefined]\n        //         240:00:59 => [\"240:00:59\", undefined, \"240\", \"00\", \"59\", undefined]\n        //         4h 18m 3s => [\"4h 18m 3s\", undefined, \"4\", \"18\", \"3\", undefined]\n        //     1d 0h 00m 59s => [\"1d 0h 00m 59s\", \"1\", \"0\", \"00\", \"59\", undefined]\n        //             2h 0m => [\"2h 0m\", undefined, \"2\", \"0\", undefined, undefined]\n        //         24h00m59s => [\"24h00m59s\", undefined, \"24\", \"00\", \"59\", undefined]\n        //      12:30:39.929 => [\"12:30:39.929\", undefined, \"12\", \"30\", \"39\", \"929\"]\n        //\n        // RegExp:\n        // /^\n        //     (?:(\\d+).+\\s)?   => (days) followed by any character 0 or more times and a space (optional)\n        //     (\\d+)[h:]\\s?     => (hours) followed by \"h\" or \":\" and an optional space\n        //     (\\d+)[m:]?\\s?    => (minutes) followed by \"m\" or \":\" and an optional space\n        //     (\\d+)?[s]?       => (seconds) followed by an optional space (optional)\n        //     (?:\\.(\\d{1,3}))? => (milliseconds) full stop character (.) and fractional part of second (optional)\n        // $/\n        parseHumanReadableDuration: function (str) {\n            var timeArray = str.match(/^(?:(\\d+).+\\s)?(\\d+)[h:]\\s?(\\d+)[m:]?\\s?(\\d+)?[s]?(?:\\.(\\d{1,3}))?$/);\n            if (timeArray) {\n                var d, dd, hh, mm, ss, ms;\n                d = new Date();\n                dd = timeArray[1] ? this.dToMs(timeArray[1]) : 0;\n                hh = timeArray[2] ? this.hToMs(timeArray[2]) : 0;\n                mm = timeArray[3] ? this.mToMs(timeArray[3]) : 0;\n                ss = timeArray[4] ? this.sToMs(timeArray[4]) : 0;\n                ms = timeArray[5] ? parseInt(timeArray[5], 10) : 0;\n                d.setTime(d.getTime() + dd + hh + mm + ss + ms);\n                return d;\n            }\n        },\n\n        // Convert seconds to milliseconds.\n        sToMs: function (s) {\n            return parseInt(s, 10) * 1000;\n        },\n\n        // Convert minutes to milliseconds.\n        mToMs: function (m) {\n            return parseInt(m, 10) * 60 * 1000;\n        },\n\n        // Convert hours to milliseconds.\n        hToMs: function (h) {\n            return parseInt(h, 10) * 60 * 60 * 1000;\n        },\n\n        // Convert days to milliseconds.\n        dToMs: function (d) {\n            return parseInt(d, 10) * 24 * 60 * 60 * 1000;\n        },\n\n        // Extract seconds (0-59) from the given timedelta expressed in milliseconds.\n        // A timedelta represents a duration, the difference between two dates or times.\n        msToS: function (ms) {\n            return parseInt((ms / 1000) % 60, 10);\n        },\n\n        // Extract minutes (0-59) from the given timedelta expressed in milliseconds.\n        msToM: function (ms) {\n            return parseInt((ms / 1000 / 60) % 60, 10);\n        },\n\n        // Extract hours (0-23) from the given timedelta expressed in milliseconds.\n        msToH: function (ms) {\n            return parseInt((ms / 1000 / 60 / 60) % 24, 10);\n        },\n\n        // Extract the number of days from the given timedelta expressed in milliseconds.\n        msToD: function (ms) {\n            return parseInt((ms / 1000 / 60 / 60 / 24), 10);\n        },\n\n        markup: function () {\n            // Prepare the HTML content of the <time> element.\n            var html = [\n                '<span class=\"item item-dd\">',\n                    '<span class=\"dd\"></span>',\n                    '<span class=\"label label-dd\">', this.options.label_dd, '</span>',\n                '</span>',\n                '<span class=\"separator separator-dd\">', this.options.separator_days, '</span>',\n                '<span class=\"item item-hh\">',\n                    '<span class=\"hh-1\"></span>',\n                    '<span class=\"hh-2\"></span>',\n                    '<span class=\"label label-hh\">', this.options.label_hh, '</span>',\n                '</span>',\n                '<span class=\"separator\">', this.options.separator, '</span>',\n                '<span class=\"item item-mm\">',\n                    '<span class=\"mm-1\"></span>',\n                    '<span class=\"mm-2\"></span>',\n                    '<span class=\"label label-mm\">', this.options.label_mm, '</span>',\n                '</span>',\n                '<span class=\"separator\">', this.options.separator, '</span>',\n                '<span class=\"item item-ss\">',\n                    '<span class=\"ss-1\"></span>',\n                    '<span class=\"ss-2\"></span>',\n                    '<span class=\"label label-ss\">', this.options.label_ss, '</span>',\n                '</span>'\n            ];\n            this.timeElement.html(html.join(''));\n            // Customize HTML according to options.\n            if (!this.options.with_labels) {\n                this.timeElement.find('.label').remove();\n            }\n            if (!this.options.with_separators) {\n                this.timeElement.find('.separator').remove();\n            }\n            if (!this.options.with_seconds) {\n                this.timeElement.find('.item-ss').remove();\n                this.timeElement.find('.separator').last().remove();\n            }\n            // Cache elements.\n            this.item_dd       = this.timeElement.find('.item-dd');\n            this.separator_dd  = this.timeElement.find('.separator-dd');\n            this.remaining_dd  = this.timeElement.find('.dd');\n            this.remaining_hh1 = this.timeElement.find('.hh-1');\n            this.remaining_hh2 = this.timeElement.find('.hh-2');\n            this.remaining_mm1 = this.timeElement.find('.mm-1');\n            this.remaining_mm2 = this.timeElement.find('.mm-2');\n            this.remaining_ss1 = this.timeElement.find('.ss-1');\n            this.remaining_ss2 = this.timeElement.find('.ss-2');\n            // Set the css class of the <time> element.\n            this.timeElement.addClass(this.options.css_class);\n        },\n\n        doCountDown: function () {\n            // Calculate the difference between the two dates in milliseconds.\n            var ms = this.endDate.getTime() - new Date().getTime();\n            // Extract seconds, minutes, hours and days from the timedelta expressed in milliseconds.\n            var ss = this.msToS(ms);\n            var mm = this.msToM(ms);\n            var hh = this.msToH(ms);\n            var dd = this.msToD(ms);\n            // Prevent display of negative values.\n            if (ms <= 0) {\n                ss = mm = hh = dd = 0;\n            }\n            // Update display.\n            // Use a space instead of 0 when no leading zero is required.\n            this.displayRemainingTime({\n                'ss': ss < 10 ? (this.options.with_ss_leading_zero ? '0' : ' ') + ss.toString() : ss.toString(),\n                'mm': mm < 10 ? (this.options.with_mm_leading_zero ? '0' : ' ') + mm.toString() : mm.toString(),\n                'hh': hh < 10 ? (this.options.with_hh_leading_zero ? '0' : ' ') + hh.toString() : hh.toString(),\n                'dd': dd.toString()\n            });\n            // If seconds are hidden, stop the counter as soon as there is no minute left.\n            if (!this.options.with_seconds && dd === 0 && mm === 0 && hh === 0) {\n                ss = 0;\n            }\n            if (dd === 0 && mm === 0 && hh === 0 && ss === 0) {\n                return this.timeElement.trigger('time.elapsed');\n            }\n            // Reload it.\n            var self = this;\n            window.setTimeout(function () { self.doCountDown(); }, self.setTimeoutDelay);\n            return this.timeElement.trigger('time.tick', ms);\n        },\n\n        /**\n         * Display the remaining time.\n         *\n         * @param {Object} remaining - an object literal containing a string representation\n         * of days, hours, minutes and seconds remaining.\n         * E.g. with leading zeros:\n         * { dd: \"600\", hh: \"03\", mm: \"59\", ss: \"11\" }\n         * Or without leading zeros:\n         * { dd: \"600\", hh: \" 3\", mm: \" 9\", ss: \"11\" }\n         */\n        displayRemainingTime: function (remaining) {\n            // Format the datetime attribute of the <time> element to an ISO 8601 duration.\n            // https://html.spec.whatwg.org/multipage/semantics.html#datetime-value\n            // I.e.: <time datetime=\"P2DT00H00M30S\">2 00:00:00</time>\n            var attr = [];\n            attr.push('P');\n            if (remaining.dd !== '0') {\n                attr.push(remaining.dd, 'D');\n            }\n            attr.push('T', remaining.hh, 'H', remaining.mm, 'M');\n            if (this.options.with_seconds) {\n                attr.push(remaining.ss, 'S');\n            }\n            this.timeElement.attr('datetime', attr.join(''));\n            // Remove days if necessary.\n            if (this.daysVisible && !this.options.always_show_days && remaining.dd === '0') {\n                this.item_dd.remove();\n                this.separator_dd.remove();\n                this.daysVisible = false;\n            }\n            // Update countdown values.\n            // Use `trim` to convert spaces to empty string when there are no leading zeros.\n            this.remaining_dd.text(remaining.dd);\n            this.remaining_hh1.text(remaining.hh[0].trim());\n            this.remaining_hh2.text(remaining.hh[1]);\n            this.remaining_mm1.text(remaining.mm[0].trim());\n            this.remaining_mm2.text(remaining.mm[1]);\n            this.remaining_ss1.text(remaining.ss[0].trim());\n            this.remaining_ss2.text(remaining.ss[1]);\n        }\n\n    });\n\n    $.fn[pluginName] = function (options) {\n\n        var args = arguments;\n\n        // If the first parameter is an object (options) or was omitted, instantiate a new plugin instance.\n        if (options === undefined || typeof options === 'object') {\n            return this.each(function () {\n                if (!$.data(this, 'plugin_' + pluginName)) {\n                    $.data(this, 'plugin_' + pluginName, new CountDown(this, options));\n                }\n            });\n        }\n\n        // Allow any public function (i.e. a function whose name isn't 'init' or doesn't start with an underscore)\n        // to be called via the jQuery plugin, e.g. $(element).countDown('functionName', arg1, arg2).\n        else if (typeof options === 'string' && options[0] !== '_' && options !== 'init') {\n\n            // Cache the method call to make it possible to return a value.\n            var returns;\n\n            this.each(function () {\n                var instance = $.data(this, 'plugin_' + pluginName);\n\n                // Tests that there's already a plugin instance and checks that the requested public method exists.\n                if (instance instanceof CountDown && typeof instance[options] === 'function') {\n                    // Call the method of our plugin instance, and pass it the supplied arguments.\n                    returns = instance[options].apply(instance, Array.prototype.slice.call(args, 1));\n                }\n\n                // Allow instances to be destroyed via the 'destroy' method.\n                if (options === 'destroy') {\n                    $.data(this, 'plugin_' + pluginName, null);\n                }\n\n            });\n\n            // If the earlier cached method gives a value back return the value,\n            // otherwise return this to preserve chainability.\n            return returns !== undefined ? returns : this;\n\n        }\n\n    };\n\n})(window.jQuery, window, document);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vanF1ZXJ5LmNvdW50ZG93bi9qcXVlcnkuY291bnRkb3duLmpzPzcwOTEiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIGpRdWVyeSBDb3VudGRvd24gLSB2MS4yLjhcbiAqIGh0dHA6Ly9naXRodWIuY29tL2tlbWFyL2pxdWVyeS5jb3VudGRvd25cbiAqIExpY2Vuc2VkIE1JVFxuICovXG5cbihmdW5jdGlvbiAoJCwgd2luZG93LCBkb2N1bWVudCwgdW5kZWZpbmVkKSB7XG5cbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8qXG4gICAgICogLmNvdW50RG93bigpXG4gICAgICpcbiAgICAgKiBEZXNjcmlwdGlvbjpcbiAgICAgKiAgICAgIFVub2J0cnVzaXZlIGFuZCBlYXNpbHkgc2tpbmFibGUgY291bnRkb3duIGpRdWVyeSBwbHVnaW4uXG4gICAgICpcbiAgICAgKiBVc2FnZTpcbiAgICAgKiAgICAgICQoZWxlbWVudCkuY291bnREb3duKClcbiAgICAgKlxuICAgICAqICAgICAgJChlbGVtZW50KSBpcyBhIHZhbGlkIDx0aW1lPiBvciBhbnkgb3RoZXIgSFRNTCB0YWcgY29udGFpbmluZyBhIHRleHQgcmVwcmVzZW50YXRpb24gb2YgYSBkYXRlL3RpbWVcbiAgICAgKiAgICAgIG9yIGR1cmF0aW9uIHJlbWFpbmluZyBiZWZvcmUgYSBkZWFkbGluZSBleHBpcmVzLlxuICAgICAqICAgICAgSWYgJChlbGVtZW50KSBpcyBhIDx0aW1lPiB0YWcsIHRoZSBkYXRldGltZSBhdHRyaWJ1dGUgaXMgY2hlY2tlZCBmaXJzdC5cbiAgICAgKiAgICAgICAgICA8dGltZSBkYXRldGltZT1cIjIwMTMtMTItMTNUMTc6NDM6MDBcIj5GcmlkYXksIERlY2VtYmVyIDEzdGgsIDIwMTMgNTo0M3BtPC90aW1lPlxuICAgICAqICAgICAgICAgIDx0aW1lPjIwMTItMTItMDhUMTQ6MzA6MDArMDEwMDwvdGltZT5cbiAgICAgKiAgICAgICAgICA8dGltZT5QVDAxSDAxTTE1UzwvdGltZT5cbiAgICAgKiAgICAgICAgICA8aDE+NjAwIGRheXMsIDM6NTk6MTI8L2gxPlxuICAgICAqXG4gICAgICogICAgICBUaGUgdGV4dCByZXByZXNlbnRhdGlvbiBvZiBhIGRhdGUvdGltZSBvciBkdXJhdGlvbiBjYW4gYmU6XG4gICAgICogICAgICAtIGEgdmFsaWQgZHVyYXRpb24gc3RyaW5nOlxuICAgICAqICAgICAgICAgIFBUMDBNMTBTXG4gICAgICogICAgICAgICAgUFQwMUgwMU0xNVNcbiAgICAgKiAgICAgICAgICBQMkRUMjBIMDBNMTBTXG4gICAgICogICAgICAtIGEgdmFsaWQgZ2xvYmFsIGRhdGUgYW5kIHRpbWUgc3RyaW5nIHdpdGggaXRzIHRpbWV6b25lIG9mZnNldDpcbiAgICAgKiAgICAgICAgICAyMDEyLTEyLTA4VDE0OjMwOjAwLjQzMiswMTAwXG4gICAgICogICAgICAgICAgMjAxMi0xMi0wOFQwNTozMDowMC0wODAwXG4gICAgICogICAgICAgICAgMjAxMi0xMi0wOFQxMzozMFpcbiAgICAgKiAgICAgIC0gYSB2YWxpZCB0aW1lIHN0cmluZzpcbiAgICAgKiAgICAgICAgICAxMjozMFxuICAgICAqICAgICAgICAgIDEyOjMwOjM5XG4gICAgICogICAgICAgICAgMTI6MzA6MzkuOTI5XG4gICAgICogICAgICAtIGEgaHVtYW4gcmVhZGFibGUgZHVyYXRpb24gc3RyaW5nOlxuICAgICAqICAgICAgICAgIDJoIDBtXG4gICAgICogICAgICAgICAgNGggMThtIDNzXG4gICAgICogICAgICAgICAgMjRoMDBtNTlzXG4gICAgICogICAgICAgICAgNjAwIGpvdXJzLCAzOjU5OjEyXG4gICAgICogICAgICAgICAgNjAwIGRheXMsIDM6NTk6MTJcbiAgICAgKiAgICAgIC0gdGhlIG91dHB1dCBvZiBhIEphdmFTY3JpcHQgRGF0ZS5wYXJzZSgpIHBhcnNhYmxlIHN0cmluZzpcbiAgICAgKiAgICAgICAgICBEYXRlLnRvRGF0ZVN0cmluZygpID0+IFNhdCBEZWMgMjAgMjAxNFxuICAgICAqICAgICAgICAgIERhdGUudG9HTVRTdHJpbmcoKSAgPT4gU2F0LCAyMCBEZWMgMjAxNCAwOToyNDowMCBHTVRcbiAgICAgKiAgICAgICAgICBEYXRlLnRvVVRDU3RyaW5nKCkgID0+IFNhdCwgMjAgRGVjIDIwMTQgMDk6MjQ6MDAgR01UXG4gICAgICpcbiAgICAgKiAgICAgIElmICQoZWxlbWVudCkgaXMgbm90IGEgPHRpbWU+IHRhZywgYSBuZXcgb25lIGlzIGNyZWF0ZWQgYW5kIGFwcGVuZGVkIHRvICQoZWxlbWVudCkuXG4gICAgICpcbiAgICAgKiBMaXRlcmF0dXJlLCByZXNvdXJjZXMgYW5kIGluc3BpcmF0aW9uOlxuICAgICAqICAgICAgSmF2YVNjcmlwdCBEYXRlIHJlZmVyZW5jZTpcbiAgICAgKiAgICAgICAgICBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGVcbiAgICAgKiAgICAgIEFib3V0IHRoZSA8dGltZT4gZWxlbWVudDpcbiAgICAgKiAgICAgICAgICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zZW1hbnRpY3MuaHRtbCN0aGUtdGltZS1lbGVtZW50XG4gICAgICogICAgICAgICAgaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvdGV4dC1sZXZlbC1zZW1hbnRpY3MuaHRtbCN0aGUtdGltZS1lbGVtZW50XG4gICAgICogICAgICAgICAgaHR0cDovL3dpa2kud2hhdHdnLm9yZy93aWtpL1RpbWVfZWxlbWVudFxuICAgICAqICAgICAgPHRpbWU+IGhpc3Rvcnk6XG4gICAgICogICAgICAgICAgaHR0cDovL3d3dy5icnVjZWxhd3Nvbi5jby51ay8yMDEyL2Jlc3Qtb2YtdGltZS9cbiAgICAgKiAgICAgICAgICBodHRwOi8vd3d3LndlYm1vbmtleS5jb20vMjAxMS8xMS93M2MtYWRkcy10aW1lLWVsZW1lbnQtYmFjay10by1odG1sNS9cbiAgICAgKiAgICAgIEZvcm1hdHM6XG4gICAgICogICAgICAgICAgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fODYwMVxuICAgICAqICAgICAgalF1ZXJ5IHBsdWdpbiBzeW50YXg6XG4gICAgICogICAgICAgICAgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS1ib2lsZXJwbGF0ZS9qcXVlcnktcGF0dGVybnNcbiAgICAgKiAgICAgICAgICBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5LWJvaWxlcnBsYXRlL2pxdWVyeS1ib2lsZXJwbGF0ZS93aWtpL0V4dGVuZGluZy1qUXVlcnktQm9pbGVycGxhdGVcbiAgICAgKiAgICAgICAgICBodHRwOi8vZnJlZGVyaWN0b251Zy5uZXQvanF1ZXJ5LXBsdWdpbi1kZXZlbG9wbWVudC13aXRoLXRoZS1qcXVlcnktYm9pbGVycGxhdGVcbiAgICAgKlxuICAgICAqIEV4YW1wbGUgb2YgZ2VuZXJhdGVkIEhUTUwgbWFya3VwOlxuICAgICAqICAgICAgPHRpbWUgY2xhc3M9XCJjb3VudGRvd25cIiBkYXRldGltZT1cIlAxMkRUMDVIMTZNMjJTXCI+XG4gICAgICogICAgICAgICAgPHNwYW4gY2xhc3M9XCJpdGVtIGl0ZW0tZGRcIj5cbiAgICAgKiAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJkZFwiPjwvc3Bhbj5cbiAgICAgKiAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJsYWJlbCBsYWJlbC1kZFwiPmRheXM8L3NwYW4+XG4gICAgICogICAgICAgICAgPC9zcGFuPlxuICAgICAqICAgICAgICAgIDxzcGFuIGNsYXNzPVwic2VwYXJhdG9yIHNlcGFyYXRvci1kZFwiPiw8L3NwYW4+XG4gICAgICogICAgICAgICAgPHNwYW4gY2xhc3M9XCJpdGVtIGl0ZW0taGhcIj5cbiAgICAgKiAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJoaC0xXCI+PC9zcGFuPlxuICAgICAqICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImhoLTJcIj48L3NwYW4+XG4gICAgICogICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwibGFiZWwgbGFiZWwtaGhcIj5ob3Vyczwvc3Bhbj5cbiAgICAgKiAgICAgICAgICA8L3NwYW4+XG4gICAgICogICAgICAgICAgPHNwYW4gY2xhc3M9XCJzZXBhcmF0b3JcIj46PC9zcGFuPlxuICAgICAqICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaXRlbSBpdGVtLW1tXCI+XG4gICAgICogICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwibW0tMVwiPjwvc3Bhbj5cbiAgICAgKiAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJtbS0yXCI+PC9zcGFuPlxuICAgICAqICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImxhYmVsIGxhYmVsLW1tXCI+bWludXRlczwvc3Bhbj5cbiAgICAgKiAgICAgICAgICA8L3NwYW4+XG4gICAgICogICAgICAgICAgPHNwYW4gY2xhc3M9XCJzZXBhcmF0b3JcIj46PC9zcGFuPlxuICAgICAqICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaXRlbSBpdGVtLXNzXCI+XG4gICAgICogICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwic3MtMVwiPjwvc3Bhbj5cbiAgICAgKiAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJzcy0yXCI+PC9zcGFuPlxuICAgICAqICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImxhYmVsIGxhYmVsLXNzXCI+c2Vjb25kczwvc3Bhbj5cbiAgICAgKiAgICAgICAgICA8L3NwYW4+XG4gICAgICogICAgICA8L3RpbWU+XG4gICAgICovXG5cbiAgICB2YXIgcGx1Z2luTmFtZSA9ICdjb3VudERvd24nO1xuXG4gICAgdmFyIGRlZmF1bHRzID0ge1xuICAgICAgICBjc3NfY2xhc3M6ICdjb3VudGRvd24nLFxuICAgICAgICBhbHdheXNfc2hvd19kYXlzOiBmYWxzZSxcbiAgICAgICAgd2l0aF9sYWJlbHM6IHRydWUsXG4gICAgICAgIHdpdGhfc2Vjb25kczogdHJ1ZSxcbiAgICAgICAgd2l0aF9zZXBhcmF0b3JzOiB0cnVlLFxuICAgICAgICB3aXRoX2hoX2xlYWRpbmdfemVybzogdHJ1ZSxcbiAgICAgICAgd2l0aF9tbV9sZWFkaW5nX3plcm86IHRydWUsXG4gICAgICAgIHdpdGhfc3NfbGVhZGluZ196ZXJvOiB0cnVlLFxuICAgICAgICBsYWJlbF9kZDogJ2RheXMnLFxuICAgICAgICBsYWJlbF9oaDogJ2hvdXJzJyxcbiAgICAgICAgbGFiZWxfbW06ICdtaW51dGVzJyxcbiAgICAgICAgbGFiZWxfc3M6ICdzZWNvbmRzJyxcbiAgICAgICAgc2VwYXJhdG9yOiAnOicsXG4gICAgICAgIHNlcGFyYXRvcl9kYXlzOiAnLCdcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gQ291bnREb3duKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gJChlbGVtZW50KTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gJC5leHRlbmQoe30sIGRlZmF1bHRzLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fZGVmYXVsdHMgPSBkZWZhdWx0cztcbiAgICAgICAgdGhpcy5fbmFtZSA9IHBsdWdpbk5hbWU7XG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgIH1cblxuICAgICQuZXh0ZW5kKENvdW50RG93bi5wcm90b3R5cGUsIHtcblxuICAgICAgICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5lbGVtZW50LmNoaWxkcmVuKCkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZWxlbWVudC5hdHRyKCdkYXRldGltZScpKSB7ICAvLyBUcnkgdG8gcGFyc2UgdGhlIGRhdGV0aW1lIGF0dHJpYnV0ZSBmaXJzdC5cbiAgICAgICAgICAgICAgICB0aGlzLmVuZERhdGUgPSB0aGlzLnBhcnNlRW5kRGF0ZSh0aGlzLmVsZW1lbnQuYXR0cignZGF0ZXRpbWUnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5lbmREYXRlID09PSB1bmRlZmluZWQpIHsgIC8vIEZhbGxiYWNrIG9uIHRoZSB0ZXh0IGNvbnRlbnQuXG4gICAgICAgICAgICAgICAgdGhpcy5lbmREYXRlID0gdGhpcy5wYXJzZUVuZERhdGUodGhpcy5lbGVtZW50LnRleHQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5lbmREYXRlID09PSB1bmRlZmluZWQpIHsgIC8vIFVuYWJsZSB0byBwYXJzZSBhIGRhdGUuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZWxlbWVudC5pcygndGltZScpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50aW1lRWxlbWVudCA9IHRoaXMuZWxlbWVudDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy50aW1lRWxlbWVudCA9ICQoJzx0aW1lPjwvdGltZT4nKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuaHRtbCh0aGlzLnRpbWVFbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubWFya3VwKCk7XG4gICAgICAgICAgICB0aGlzLnNldFRpbWVvdXREZWxheSA9IHRoaXMuc1RvTXMoMSk7XG4gICAgICAgICAgICB0aGlzLmRheXNWaXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMudGltZUVsZW1lbnQub24oJ3RpbWUuZWxhcHNlZCcsIHRoaXMub3B0aW9ucy5vblRpbWVFbGFwc2VkKTtcbiAgICAgICAgICAgIHRoaXMudGltZUVsZW1lbnQub24oJ3RpbWUudGljaycsIHRoaXMub3B0aW9ucy5vblRpY2spO1xuICAgICAgICAgICAgdGhpcy5kb0NvdW50RG93bigpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBhcnNlRW5kRGF0ZTogZnVuY3Rpb24gKHN0cikge1xuXG4gICAgICAgICAgICB2YXIgZDtcblxuICAgICAgICAgICAgZCA9IHRoaXMucGFyc2VEdXJhdGlvbihzdHIpO1xuICAgICAgICAgICAgaWYgKGQgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGQgPSB0aGlzLnBhcnNlRGF0ZVRpbWUoc3RyKTtcbiAgICAgICAgICAgIGlmIChkIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkID0gdGhpcy5wYXJzZUh1bWFuUmVhZGFibGVEdXJhdGlvbihzdHIpO1xuICAgICAgICAgICAgaWYgKGQgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRyeSB0byBwYXJzZSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIGRhdGUuXG4gICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlL3BhcnNlXG4gICAgICAgICAgICBkID0gRGF0ZS5wYXJzZShzdHIpO1xuICAgICAgICAgICAgaWYgKCFpc05hTihkKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIENvbnZlcnQgYSB2YWxpZCBkdXJhdGlvbiBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZHVyYXRpb24gdG8gYSBEYXRlIG9iamVjdC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5mcmFzdHJ1Y3R1cmUuaHRtbCN2YWxpZC1kdXJhdGlvbi1zdHJpbmdcbiAgICAgICAgLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fODYwMSNEdXJhdGlvbnNcbiAgICAgICAgLy8gaS5lLjogUDJEVDIwSDAwTTEwUywgUFQwMUgwMU0xNVMsIFBUMDBNMTBTLCBQMkQsIFAyRFQyMEgwME0xMC41NVNcbiAgICAgICAgLy9cbiAgICAgICAgLy8gUmVnRXhwOlxuICAgICAgICAvLyAvXlxuICAgICAgICAvLyAgICBQICAgICAgICAgICAgICAgICAgICAgPT4gZHVyYXRpb24gZGVzaWduYXRvciAoaGlzdG9yaWNhbGx5IGNhbGxlZCBcInBlcmlvZFwiKVxuICAgICAgICAvLyAgICAoPzooXFxkKylEKT8gICAgICAgICAgID0+IChkYXlzKSBmb2xsb3dlZCBieSB0aGUgbGV0dGVyIFwiRFwiIChvcHRpb25hbClcbiAgICAgICAgLy8gICAgVD8gICAgICAgICAgICAgICAgICAgID0+IHRoZSBsZXR0ZXIgXCJUXCIgdGhhdCBwcmVjZWRlcyB0aGUgdGltZSBjb21wb25lbnRzIG9mIHRoZSByZXByZXNlbnRhdGlvbiAob3B0aW9uYWwpXG4gICAgICAgIC8vICAgICg/OihcXGQrKUgpPyAgICAgICAgICAgPT4gKGhvdXJzKSBmb2xsb3dlZCBieSB0aGUgbGV0dGVyIFwiSFwiIChvcHRpb25hbClcbiAgICAgICAgLy8gICAgKD86KFxcZCspTSk/ICAgICAgICAgICA9PiAobWludXRlcykgZm9sbG93ZWQgYnkgdGhlIGxldHRlciBcIk1cIiAob3B0aW9uYWwpXG4gICAgICAgIC8vICAgIChcbiAgICAgICAgLy8gICAgICAgICA/OihcXGQrKSAgICAgICAgICA9PiAoc2Vjb25kcykgKG9wdGlvbmFsKVxuICAgICAgICAvLyAgICAgICAgICg/OlxcLihcXGR7MSwzfSkpPyA9PiAobWlsbGlzZWNvbmRzKSBmdWxsIHN0b3AgY2hhcmFjdGVyICguKSBhbmQgZnJhY3Rpb25hbCBwYXJ0IG9mIHNlY29uZCAob3B0aW9uYWwpXG4gICAgICAgIC8vICAgICAgICAgUyAgICAgICAgICAgICAgICA9PiBmb2xsb3dlZCBieSB0aGUgbGV0dGVyIFwiU1wiXG4gICAgICAgIC8vICAgICk/XG4gICAgICAgIC8vICQvXG4gICAgICAgIHBhcnNlRHVyYXRpb246IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgICAgIHZhciB0aW1lQXJyYXkgPSBzdHIubWF0Y2goL15QKD86KFxcZCspRCk/VD8oPzooXFxkKylIKT8oPzooXFxkKylNKT8oPzooXFxkKykoPzpcXC4oXFxkezEsM30pKT9TKT8kLyk7XG4gICAgICAgICAgICBpZiAodGltZUFycmF5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGQsIGRkLCBoaCwgbW0sIHNzLCBtcztcbiAgICAgICAgICAgICAgICBkZCA9IHRpbWVBcnJheVsxXSA/IHRoaXMuZFRvTXModGltZUFycmF5WzFdKSA6IDA7XG4gICAgICAgICAgICAgICAgaGggPSB0aW1lQXJyYXlbMl0gPyB0aGlzLmhUb01zKHRpbWVBcnJheVsyXSkgOiAwO1xuICAgICAgICAgICAgICAgIG1tID0gdGltZUFycmF5WzNdID8gdGhpcy5tVG9Ncyh0aW1lQXJyYXlbM10pIDogMDtcbiAgICAgICAgICAgICAgICBzcyA9IHRpbWVBcnJheVs0XSA/IHRoaXMuc1RvTXModGltZUFycmF5WzRdKSA6IDA7XG4gICAgICAgICAgICAgICAgbXMgPSB0aW1lQXJyYXlbNV0gPyBwYXJzZUludCh0aW1lQXJyYXlbNV0sIDEwKSA6IDA7XG4gICAgICAgICAgICAgICAgZCA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICAgICAgZC5zZXRUaW1lKGQuZ2V0VGltZSgpICsgZGQgKyBoaCArIG1tICsgc3MgKyBtcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gQ29udmVydCBhIHZhbGlkIGdsb2JhbCBkYXRlIGFuZCB0aW1lIHN0cmluZyB0byBhIERhdGUgb2JqZWN0LlxuICAgICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbmZyYXN0cnVjdHVyZS5odG1sI3ZhbGlkLWdsb2JhbC1kYXRlLWFuZC10aW1lLXN0cmluZ1xuICAgICAgICAvL1xuICAgICAgICAvLyAyMDEyLTEyLTA4VDEzOjMwOjM5KzAxMDBcbiAgICAgICAgLy8gICAgID0+IFtcIjIwMTItMTItMDhUMTM6MzA6MzkrMDEwMFwiLCBcIjIwMTJcIiwgXCIxMlwiLCBcIjA4XCIsIFwiMTNcIiwgXCIzMFwiLCBcIjM5XCIsIHVuZGVmaW5lZCwgXCIrMDEwMFwiXVxuICAgICAgICAvLyAyMDEyLTEyLTA4VDA2OjU0LTA4MDBcbiAgICAgICAgLy8gICAgID0+IFtcIjIwMTItMTItMDhUMDY6NTQtMDgwMFwiLCBcIjIwMTJcIiwgXCIxMlwiLCBcIjA4XCIsIFwiMDZcIiwgXCI1NFwiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgXCItMDgwMFwiXVxuICAgICAgICAvLyAyMDEyLTEyLTA4IDEzOjMwWlxuICAgICAgICAvLyAgICAgPT4gW1wiMjAxMi0xMi0wOCAxMzozMFpcIiwgXCIyMDEyXCIsIFwiMTJcIiwgXCIwOFwiLCBcIjEzXCIsIFwiMzBcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFwiWlwiXVxuICAgICAgICAvLyAyMDEzLTEyLTA4IDA2OjU0OjM5LjkyOS0xMDozMFxuICAgICAgICAvLyAgICAgPT4gW1wiMjAxMy0xMi0wOCAwNjo1NDozOS45MjktMDg6MzBcIiwgXCIyMDEzXCIsIFwiMTJcIiwgXCIwOFwiLCBcIjA2XCIsIFwiNTRcIiwgXCIzOVwiLCBcIjkyOVwiLCBcIi0xMDozMFwiXVxuICAgICAgICAvL1xuICAgICAgICAvLyBSZWdFeHA6XG4gICAgICAgIC8vIF5cbiAgICAgICAgLy8gICAgIChcXGR7NCx9KSAgICAgICAgID0+ICh5ZWFyKSAoZm91ciBvciBtb3JlIEFTQ0lJIGRpZ2l0cylcbiAgICAgICAgLy8gICAgIC0gICAgICAgICAgICAgICAgPT4gaHlwaGVuLW1pbnVzXG4gICAgICAgIC8vICAgICAoXFxkezJ9KSAgICAgICAgICA9PiAobW9udGgpXG4gICAgICAgIC8vICAgICAtICAgICAgICAgICAgICAgID0+IGh5cGhlbi1taW51c1xuICAgICAgICAvLyAgICAgKFxcZHsyfSkgICAgICAgICAgPT4gKGRheSlcbiAgICAgICAgLy8gICAgIFtUXFxzXSAgICAgICAgICAgID0+IFQgb3Igc3BhY2VcbiAgICAgICAgLy8gICAgIChcXGR7Mn0pICAgICAgICAgID0+IChob3VycylcbiAgICAgICAgLy8gICAgIDogICAgICAgICAgICAgICAgPT4gY29sb25cbiAgICAgICAgLy8gICAgIChcXGR7Mn0pICAgICAgICAgID0+IChtaW51dGVzKVxuICAgICAgICAvLyAgICAgKD86XFw6KFxcZHsyfSkpPyAgID0+IGNvbG9uIGFuZCAoc2Vjb25kcykgKG9wdGlvbmFsKVxuICAgICAgICAvLyAgICAgKD86XFwuKFxcZHsxLDN9KSk/ID0+IGZ1bGwgc3RvcCBjaGFyYWN0ZXIgKC4pIGFuZCBmcmFjdGlvbmFsIHBhcnQgb2Ygc2Vjb25kIChtaWxsaXNlY29uZHMpIChvcHRpb25hbClcbiAgICAgICAgLy8gICAgIChbWlxcK1xcLVxcOlxcZF0rKT8gID0+IHRpbWUtem9uZSAob2Zmc2V0KSBzdHJpbmcgKG9wdGlvbmFsKVxuICAgICAgICAvLyAkXG4gICAgICAgIHBhcnNlRGF0ZVRpbWU6IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgICAgIHZhciB0aW1lQXJyYXkgPSBzdHIubWF0Y2goXG4gICAgICAgICAgICAgICAgL14oXFxkezQsfSktKFxcZHsyfSktKFxcZHsyfSlbVFxcc10oXFxkezJ9KTooXFxkezJ9KSg/OlxcOihcXGR7Mn0pKT8oPzpcXC4oXFxkezEsM30pKT8oW1pcXCtcXC1cXDpcXGRdKyk/JC8pO1xuICAgICAgICAgICAgaWYgKHRpbWVBcnJheSkge1xuXG4gICAgICAgICAgICAgICAgLy8gQ29udmVydCBVVEMgb2Zmc2V0IGZyb20gc3RyaW5nIHRvIG1pbGxpc2Vjb25kcy5cbiAgICAgICAgICAgICAgICAvLyArMDE6MDAgPT4gW1wiKzAxOjAwXCIsIFwiK1wiLCBcIjAxXCIsIFwiMDBcIl0gPT4gLTM2MDAwMFxuICAgICAgICAgICAgICAgIC8vIC0wODowMCA9PiBbXCItMDg6MDBcIiwgXCItXCIsIFwiMDhcIiwgXCIwMFwiXSA9PiAyODgwMDAwMFxuICAgICAgICAgICAgICAgIC8vICswNTozMCA9PiBbXCIrMDU6MzBcIiwgXCIrXCIsIFwiMDVcIiwgXCIzMFwiXSA9PiAtMTk4MDAwMDBcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdGltZUFycmF5WzhdID8gdGltZUFycmF5WzhdLm1hdGNoKC9eKFtcXCtcXC1dKT8oXFxkezJ9KTo/KFxcZHsyfSkkLykgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgICAgICAvLyBUaW1lIGRpZmZlcmVuY2UgYmV0d2VlbiBVVEMgYW5kIHRoZSBnaXZlbiB0aW1lIHpvbmUgaW4gbWlsbGlzZWNvbmRzLlxuICAgICAgICAgICAgICAgIHZhciB1dGNPZmZzZXQgPSAwO1xuICAgICAgICAgICAgICAgIGlmIChvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdXRjT2Zmc2V0ID0gdGhpcy5oVG9NcyhvZmZzZXRbMl0pICsgdGhpcy5tVG9NcyhvZmZzZXRbM10pO1xuICAgICAgICAgICAgICAgICAgICB1dGNPZmZzZXQgPSAob2Zmc2V0WzFdID09PSAnLScpID8gdXRjT2Zmc2V0IDogLXV0Y09mZnNldDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgZCwgeXksIG1vLCBkZCwgaGgsIG1tLCBzcywgbXM7XG4gICAgICAgICAgICAgICAgeXkgPSB0aW1lQXJyYXlbMV07XG4gICAgICAgICAgICAgICAgbW8gPSB0aW1lQXJyYXlbMl0gLSAxO1xuICAgICAgICAgICAgICAgIGRkID0gdGltZUFycmF5WzNdO1xuICAgICAgICAgICAgICAgIGhoID0gdGltZUFycmF5WzRdIHx8IDA7XG4gICAgICAgICAgICAgICAgbW0gPSB0aW1lQXJyYXlbNV0gfHwgMDtcbiAgICAgICAgICAgICAgICBzcyA9IHRpbWVBcnJheVs2XSB8fCAwO1xuICAgICAgICAgICAgICAgIG1zID0gdGltZUFycmF5WzddIHx8IDA7XG4gICAgICAgICAgICAgICAgZCA9IG5ldyBEYXRlKERhdGUuVVRDKHl5LCBtbywgZGQsIGhoLCBtbSwgc3MsIG1zKSk7XG5cbiAgICAgICAgICAgICAgICBkLnNldFRpbWUoZC5nZXRUaW1lKCkgKyB1dGNPZmZzZXQpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGQ7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBDb252ZXJ0IGEgc3RyaW5nIHJlcHJlc2VudGluZyBhIGh1bWFuIHJlYWRhYmxlIGR1cmF0aW9uIHRvIGEgRGF0ZSBvYmplY3QuXG4gICAgICAgIC8vIEhvdXJzIGFuZCBtaW51dGVzIGFyZSBtYW5kYXRvcnkuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIDYwMCBkYXlzLCAzOjU5OjEyID0+IFtcIjYwMCBkYXlzLCAzOjU5OjEyXCIsIFwiNjAwXCIsIFwiM1wiLCBcIjU5XCIsIFwiMTJcIiwgdW5kZWZpbmVkXVxuICAgICAgICAvLyAgICAgICAgICAgMzo1OToxMiA9PiBbXCIzOjU5OjEyXCIsIHVuZGVmaW5lZCwgXCIzXCIsIFwiNTlcIiwgXCIxMlwiLCB1bmRlZmluZWRdXG4gICAgICAgIC8vICAgICAgICAgICAgIDAwOjAxID0+IFtcIjAwOjAxXCIsIHVuZGVmaW5lZCwgXCIwMFwiLCBcIjAxXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkXVxuICAgICAgICAvLyAgICAgICAgICAwMDowMDo1OSA9PiBbXCIwMDowMDo1OVwiLCB1bmRlZmluZWQsIFwiMDBcIiwgXCIwMFwiLCBcIjU5XCIsIHVuZGVmaW5lZF1cbiAgICAgICAgLy8gICAgICAgICAyNDA6MDA6NTkgPT4gW1wiMjQwOjAwOjU5XCIsIHVuZGVmaW5lZCwgXCIyNDBcIiwgXCIwMFwiLCBcIjU5XCIsIHVuZGVmaW5lZF1cbiAgICAgICAgLy8gICAgICAgICA0aCAxOG0gM3MgPT4gW1wiNGggMThtIDNzXCIsIHVuZGVmaW5lZCwgXCI0XCIsIFwiMThcIiwgXCIzXCIsIHVuZGVmaW5lZF1cbiAgICAgICAgLy8gICAgIDFkIDBoIDAwbSA1OXMgPT4gW1wiMWQgMGggMDBtIDU5c1wiLCBcIjFcIiwgXCIwXCIsIFwiMDBcIiwgXCI1OVwiLCB1bmRlZmluZWRdXG4gICAgICAgIC8vICAgICAgICAgICAgIDJoIDBtID0+IFtcIjJoIDBtXCIsIHVuZGVmaW5lZCwgXCIyXCIsIFwiMFwiLCB1bmRlZmluZWQsIHVuZGVmaW5lZF1cbiAgICAgICAgLy8gICAgICAgICAyNGgwMG01OXMgPT4gW1wiMjRoMDBtNTlzXCIsIHVuZGVmaW5lZCwgXCIyNFwiLCBcIjAwXCIsIFwiNTlcIiwgdW5kZWZpbmVkXVxuICAgICAgICAvLyAgICAgIDEyOjMwOjM5LjkyOSA9PiBbXCIxMjozMDozOS45MjlcIiwgdW5kZWZpbmVkLCBcIjEyXCIsIFwiMzBcIiwgXCIzOVwiLCBcIjkyOVwiXVxuICAgICAgICAvL1xuICAgICAgICAvLyBSZWdFeHA6XG4gICAgICAgIC8vIC9eXG4gICAgICAgIC8vICAgICAoPzooXFxkKykuK1xccyk/ICAgPT4gKGRheXMpIGZvbGxvd2VkIGJ5IGFueSBjaGFyYWN0ZXIgMCBvciBtb3JlIHRpbWVzIGFuZCBhIHNwYWNlIChvcHRpb25hbClcbiAgICAgICAgLy8gICAgIChcXGQrKVtoOl1cXHM/ICAgICA9PiAoaG91cnMpIGZvbGxvd2VkIGJ5IFwiaFwiIG9yIFwiOlwiIGFuZCBhbiBvcHRpb25hbCBzcGFjZVxuICAgICAgICAvLyAgICAgKFxcZCspW206XT9cXHM/ICAgID0+IChtaW51dGVzKSBmb2xsb3dlZCBieSBcIm1cIiBvciBcIjpcIiBhbmQgYW4gb3B0aW9uYWwgc3BhY2VcbiAgICAgICAgLy8gICAgIChcXGQrKT9bc10/ICAgICAgID0+IChzZWNvbmRzKSBmb2xsb3dlZCBieSBhbiBvcHRpb25hbCBzcGFjZSAob3B0aW9uYWwpXG4gICAgICAgIC8vICAgICAoPzpcXC4oXFxkezEsM30pKT8gPT4gKG1pbGxpc2Vjb25kcykgZnVsbCBzdG9wIGNoYXJhY3RlciAoLikgYW5kIGZyYWN0aW9uYWwgcGFydCBvZiBzZWNvbmQgKG9wdGlvbmFsKVxuICAgICAgICAvLyAkL1xuICAgICAgICBwYXJzZUh1bWFuUmVhZGFibGVEdXJhdGlvbjogZnVuY3Rpb24gKHN0cikge1xuICAgICAgICAgICAgdmFyIHRpbWVBcnJheSA9IHN0ci5tYXRjaCgvXig/OihcXGQrKS4rXFxzKT8oXFxkKylbaDpdXFxzPyhcXGQrKVttOl0/XFxzPyhcXGQrKT9bc10/KD86XFwuKFxcZHsxLDN9KSk/JC8pO1xuICAgICAgICAgICAgaWYgKHRpbWVBcnJheSkge1xuICAgICAgICAgICAgICAgIHZhciBkLCBkZCwgaGgsIG1tLCBzcywgbXM7XG4gICAgICAgICAgICAgICAgZCA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICAgICAgZGQgPSB0aW1lQXJyYXlbMV0gPyB0aGlzLmRUb01zKHRpbWVBcnJheVsxXSkgOiAwO1xuICAgICAgICAgICAgICAgIGhoID0gdGltZUFycmF5WzJdID8gdGhpcy5oVG9Ncyh0aW1lQXJyYXlbMl0pIDogMDtcbiAgICAgICAgICAgICAgICBtbSA9IHRpbWVBcnJheVszXSA/IHRoaXMubVRvTXModGltZUFycmF5WzNdKSA6IDA7XG4gICAgICAgICAgICAgICAgc3MgPSB0aW1lQXJyYXlbNF0gPyB0aGlzLnNUb01zKHRpbWVBcnJheVs0XSkgOiAwO1xuICAgICAgICAgICAgICAgIG1zID0gdGltZUFycmF5WzVdID8gcGFyc2VJbnQodGltZUFycmF5WzVdLCAxMCkgOiAwO1xuICAgICAgICAgICAgICAgIGQuc2V0VGltZShkLmdldFRpbWUoKSArIGRkICsgaGggKyBtbSArIHNzICsgbXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIENvbnZlcnQgc2Vjb25kcyB0byBtaWxsaXNlY29uZHMuXG4gICAgICAgIHNUb01zOiBmdW5jdGlvbiAocykge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHMsIDEwKSAqIDEwMDA7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gQ29udmVydCBtaW51dGVzIHRvIG1pbGxpc2Vjb25kcy5cbiAgICAgICAgbVRvTXM6IGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQobSwgMTApICogNjAgKiAxMDAwO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIENvbnZlcnQgaG91cnMgdG8gbWlsbGlzZWNvbmRzLlxuICAgICAgICBoVG9NczogZnVuY3Rpb24gKGgpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludChoLCAxMCkgKiA2MCAqIDYwICogMTAwMDtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBDb252ZXJ0IGRheXMgdG8gbWlsbGlzZWNvbmRzLlxuICAgICAgICBkVG9NczogZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludChkLCAxMCkgKiAyNCAqIDYwICogNjAgKiAxMDAwO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEV4dHJhY3Qgc2Vjb25kcyAoMC01OSkgZnJvbSB0aGUgZ2l2ZW4gdGltZWRlbHRhIGV4cHJlc3NlZCBpbiBtaWxsaXNlY29uZHMuXG4gICAgICAgIC8vIEEgdGltZWRlbHRhIHJlcHJlc2VudHMgYSBkdXJhdGlvbiwgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0d28gZGF0ZXMgb3IgdGltZXMuXG4gICAgICAgIG1zVG9TOiBmdW5jdGlvbiAobXMpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludCgobXMgLyAxMDAwKSAlIDYwLCAxMCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gRXh0cmFjdCBtaW51dGVzICgwLTU5KSBmcm9tIHRoZSBnaXZlbiB0aW1lZGVsdGEgZXhwcmVzc2VkIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgICAgbXNUb006IGZ1bmN0aW9uIChtcykge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KChtcyAvIDEwMDAgLyA2MCkgJSA2MCwgMTApO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEV4dHJhY3QgaG91cnMgKDAtMjMpIGZyb20gdGhlIGdpdmVuIHRpbWVkZWx0YSBleHByZXNzZWQgaW4gbWlsbGlzZWNvbmRzLlxuICAgICAgICBtc1RvSDogZnVuY3Rpb24gKG1zKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoKG1zIC8gMTAwMCAvIDYwIC8gNjApICUgMjQsIDEwKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBFeHRyYWN0IHRoZSBudW1iZXIgb2YgZGF5cyBmcm9tIHRoZSBnaXZlbiB0aW1lZGVsdGEgZXhwcmVzc2VkIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgICAgbXNUb0Q6IGZ1bmN0aW9uIChtcykge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KChtcyAvIDEwMDAgLyA2MCAvIDYwIC8gMjQpLCAxMCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbWFya3VwOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBQcmVwYXJlIHRoZSBIVE1MIGNvbnRlbnQgb2YgdGhlIDx0aW1lPiBlbGVtZW50LlxuICAgICAgICAgICAgdmFyIGh0bWwgPSBbXG4gICAgICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwiaXRlbSBpdGVtLWRkXCI+JyxcbiAgICAgICAgICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwiZGRcIj48L3NwYW4+JyxcbiAgICAgICAgICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwibGFiZWwgbGFiZWwtZGRcIj4nLCB0aGlzLm9wdGlvbnMubGFiZWxfZGQsICc8L3NwYW4+JyxcbiAgICAgICAgICAgICAgICAnPC9zcGFuPicsXG4gICAgICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwic2VwYXJhdG9yIHNlcGFyYXRvci1kZFwiPicsIHRoaXMub3B0aW9ucy5zZXBhcmF0b3JfZGF5cywgJzwvc3Bhbj4nLFxuICAgICAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cIml0ZW0gaXRlbS1oaFwiPicsXG4gICAgICAgICAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cImhoLTFcIj48L3NwYW4+JyxcbiAgICAgICAgICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwiaGgtMlwiPjwvc3Bhbj4nLFxuICAgICAgICAgICAgICAgICAgICAnPHNwYW4gY2xhc3M9XCJsYWJlbCBsYWJlbC1oaFwiPicsIHRoaXMub3B0aW9ucy5sYWJlbF9oaCwgJzwvc3Bhbj4nLFxuICAgICAgICAgICAgICAgICc8L3NwYW4+JyxcbiAgICAgICAgICAgICAgICAnPHNwYW4gY2xhc3M9XCJzZXBhcmF0b3JcIj4nLCB0aGlzLm9wdGlvbnMuc2VwYXJhdG9yLCAnPC9zcGFuPicsXG4gICAgICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwiaXRlbSBpdGVtLW1tXCI+JyxcbiAgICAgICAgICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwibW0tMVwiPjwvc3Bhbj4nLFxuICAgICAgICAgICAgICAgICAgICAnPHNwYW4gY2xhc3M9XCJtbS0yXCI+PC9zcGFuPicsXG4gICAgICAgICAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cImxhYmVsIGxhYmVsLW1tXCI+JywgdGhpcy5vcHRpb25zLmxhYmVsX21tLCAnPC9zcGFuPicsXG4gICAgICAgICAgICAgICAgJzwvc3Bhbj4nLFxuICAgICAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cInNlcGFyYXRvclwiPicsIHRoaXMub3B0aW9ucy5zZXBhcmF0b3IsICc8L3NwYW4+JyxcbiAgICAgICAgICAgICAgICAnPHNwYW4gY2xhc3M9XCJpdGVtIGl0ZW0tc3NcIj4nLFxuICAgICAgICAgICAgICAgICAgICAnPHNwYW4gY2xhc3M9XCJzcy0xXCI+PC9zcGFuPicsXG4gICAgICAgICAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cInNzLTJcIj48L3NwYW4+JyxcbiAgICAgICAgICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwibGFiZWwgbGFiZWwtc3NcIj4nLCB0aGlzLm9wdGlvbnMubGFiZWxfc3MsICc8L3NwYW4+JyxcbiAgICAgICAgICAgICAgICAnPC9zcGFuPidcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICB0aGlzLnRpbWVFbGVtZW50Lmh0bWwoaHRtbC5qb2luKCcnKSk7XG4gICAgICAgICAgICAvLyBDdXN0b21pemUgSFRNTCBhY2NvcmRpbmcgdG8gb3B0aW9ucy5cbiAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb25zLndpdGhfbGFiZWxzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50aW1lRWxlbWVudC5maW5kKCcubGFiZWwnKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb25zLndpdGhfc2VwYXJhdG9ycykge1xuICAgICAgICAgICAgICAgIHRoaXMudGltZUVsZW1lbnQuZmluZCgnLnNlcGFyYXRvcicpLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMud2l0aF9zZWNvbmRzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50aW1lRWxlbWVudC5maW5kKCcuaXRlbS1zcycpLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMudGltZUVsZW1lbnQuZmluZCgnLnNlcGFyYXRvcicpLmxhc3QoKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENhY2hlIGVsZW1lbnRzLlxuICAgICAgICAgICAgdGhpcy5pdGVtX2RkICAgICAgID0gdGhpcy50aW1lRWxlbWVudC5maW5kKCcuaXRlbS1kZCcpO1xuICAgICAgICAgICAgdGhpcy5zZXBhcmF0b3JfZGQgID0gdGhpcy50aW1lRWxlbWVudC5maW5kKCcuc2VwYXJhdG9yLWRkJyk7XG4gICAgICAgICAgICB0aGlzLnJlbWFpbmluZ19kZCAgPSB0aGlzLnRpbWVFbGVtZW50LmZpbmQoJy5kZCcpO1xuICAgICAgICAgICAgdGhpcy5yZW1haW5pbmdfaGgxID0gdGhpcy50aW1lRWxlbWVudC5maW5kKCcuaGgtMScpO1xuICAgICAgICAgICAgdGhpcy5yZW1haW5pbmdfaGgyID0gdGhpcy50aW1lRWxlbWVudC5maW5kKCcuaGgtMicpO1xuICAgICAgICAgICAgdGhpcy5yZW1haW5pbmdfbW0xID0gdGhpcy50aW1lRWxlbWVudC5maW5kKCcubW0tMScpO1xuICAgICAgICAgICAgdGhpcy5yZW1haW5pbmdfbW0yID0gdGhpcy50aW1lRWxlbWVudC5maW5kKCcubW0tMicpO1xuICAgICAgICAgICAgdGhpcy5yZW1haW5pbmdfc3MxID0gdGhpcy50aW1lRWxlbWVudC5maW5kKCcuc3MtMScpO1xuICAgICAgICAgICAgdGhpcy5yZW1haW5pbmdfc3MyID0gdGhpcy50aW1lRWxlbWVudC5maW5kKCcuc3MtMicpO1xuICAgICAgICAgICAgLy8gU2V0IHRoZSBjc3MgY2xhc3Mgb2YgdGhlIDx0aW1lPiBlbGVtZW50LlxuICAgICAgICAgICAgdGhpcy50aW1lRWxlbWVudC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuY3NzX2NsYXNzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBkb0NvdW50RG93bjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIHR3byBkYXRlcyBpbiBtaWxsaXNlY29uZHMuXG4gICAgICAgICAgICB2YXIgbXMgPSB0aGlzLmVuZERhdGUuZ2V0VGltZSgpIC0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICAvLyBFeHRyYWN0IHNlY29uZHMsIG1pbnV0ZXMsIGhvdXJzIGFuZCBkYXlzIGZyb20gdGhlIHRpbWVkZWx0YSBleHByZXNzZWQgaW4gbWlsbGlzZWNvbmRzLlxuICAgICAgICAgICAgdmFyIHNzID0gdGhpcy5tc1RvUyhtcyk7XG4gICAgICAgICAgICB2YXIgbW0gPSB0aGlzLm1zVG9NKG1zKTtcbiAgICAgICAgICAgIHZhciBoaCA9IHRoaXMubXNUb0gobXMpO1xuICAgICAgICAgICAgdmFyIGRkID0gdGhpcy5tc1RvRChtcyk7XG4gICAgICAgICAgICAvLyBQcmV2ZW50IGRpc3BsYXkgb2YgbmVnYXRpdmUgdmFsdWVzLlxuICAgICAgICAgICAgaWYgKG1zIDw9IDApIHtcbiAgICAgICAgICAgICAgICBzcyA9IG1tID0gaGggPSBkZCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVcGRhdGUgZGlzcGxheS5cbiAgICAgICAgICAgIC8vIFVzZSBhIHNwYWNlIGluc3RlYWQgb2YgMCB3aGVuIG5vIGxlYWRpbmcgemVybyBpcyByZXF1aXJlZC5cbiAgICAgICAgICAgIHRoaXMuZGlzcGxheVJlbWFpbmluZ1RpbWUoe1xuICAgICAgICAgICAgICAgICdzcyc6IHNzIDwgMTAgPyAodGhpcy5vcHRpb25zLndpdGhfc3NfbGVhZGluZ196ZXJvID8gJzAnIDogJyAnKSArIHNzLnRvU3RyaW5nKCkgOiBzcy50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICdtbSc6IG1tIDwgMTAgPyAodGhpcy5vcHRpb25zLndpdGhfbW1fbGVhZGluZ196ZXJvID8gJzAnIDogJyAnKSArIG1tLnRvU3RyaW5nKCkgOiBtbS50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICdoaCc6IGhoIDwgMTAgPyAodGhpcy5vcHRpb25zLndpdGhfaGhfbGVhZGluZ196ZXJvID8gJzAnIDogJyAnKSArIGhoLnRvU3RyaW5nKCkgOiBoaC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICdkZCc6IGRkLnRvU3RyaW5nKClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gSWYgc2Vjb25kcyBhcmUgaGlkZGVuLCBzdG9wIHRoZSBjb3VudGVyIGFzIHNvb24gYXMgdGhlcmUgaXMgbm8gbWludXRlIGxlZnQuXG4gICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy53aXRoX3NlY29uZHMgJiYgZGQgPT09IDAgJiYgbW0gPT09IDAgJiYgaGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBzcyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGQgPT09IDAgJiYgbW0gPT09IDAgJiYgaGggPT09IDAgJiYgc3MgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50aW1lRWxlbWVudC50cmlnZ2VyKCd0aW1lLmVsYXBzZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlbG9hZCBpdC5cbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgc2VsZi5kb0NvdW50RG93bigpOyB9LCBzZWxmLnNldFRpbWVvdXREZWxheSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50aW1lRWxlbWVudC50cmlnZ2VyKCd0aW1lLnRpY2snLCBtcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc3BsYXkgdGhlIHJlbWFpbmluZyB0aW1lLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVtYWluaW5nIC0gYW4gb2JqZWN0IGxpdGVyYWwgY29udGFpbmluZyBhIHN0cmluZyByZXByZXNlbnRhdGlvblxuICAgICAgICAgKiBvZiBkYXlzLCBob3VycywgbWludXRlcyBhbmQgc2Vjb25kcyByZW1haW5pbmcuXG4gICAgICAgICAqIEUuZy4gd2l0aCBsZWFkaW5nIHplcm9zOlxuICAgICAgICAgKiB7IGRkOiBcIjYwMFwiLCBoaDogXCIwM1wiLCBtbTogXCI1OVwiLCBzczogXCIxMVwiIH1cbiAgICAgICAgICogT3Igd2l0aG91dCBsZWFkaW5nIHplcm9zOlxuICAgICAgICAgKiB7IGRkOiBcIjYwMFwiLCBoaDogXCIgM1wiLCBtbTogXCIgOVwiLCBzczogXCIxMVwiIH1cbiAgICAgICAgICovXG4gICAgICAgIGRpc3BsYXlSZW1haW5pbmdUaW1lOiBmdW5jdGlvbiAocmVtYWluaW5nKSB7XG4gICAgICAgICAgICAvLyBGb3JtYXQgdGhlIGRhdGV0aW1lIGF0dHJpYnV0ZSBvZiB0aGUgPHRpbWU+IGVsZW1lbnQgdG8gYW4gSVNPIDg2MDEgZHVyYXRpb24uXG4gICAgICAgICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zZW1hbnRpY3MuaHRtbCNkYXRldGltZS12YWx1ZVxuICAgICAgICAgICAgLy8gSS5lLjogPHRpbWUgZGF0ZXRpbWU9XCJQMkRUMDBIMDBNMzBTXCI+MiAwMDowMDowMDwvdGltZT5cbiAgICAgICAgICAgIHZhciBhdHRyID0gW107XG4gICAgICAgICAgICBhdHRyLnB1c2goJ1AnKTtcbiAgICAgICAgICAgIGlmIChyZW1haW5pbmcuZGQgIT09ICcwJykge1xuICAgICAgICAgICAgICAgIGF0dHIucHVzaChyZW1haW5pbmcuZGQsICdEJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhdHRyLnB1c2goJ1QnLCByZW1haW5pbmcuaGgsICdIJywgcmVtYWluaW5nLm1tLCAnTScpO1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy53aXRoX3NlY29uZHMpIHtcbiAgICAgICAgICAgICAgICBhdHRyLnB1c2gocmVtYWluaW5nLnNzLCAnUycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy50aW1lRWxlbWVudC5hdHRyKCdkYXRldGltZScsIGF0dHIuam9pbignJykpO1xuICAgICAgICAgICAgLy8gUmVtb3ZlIGRheXMgaWYgbmVjZXNzYXJ5LlxuICAgICAgICAgICAgaWYgKHRoaXMuZGF5c1Zpc2libGUgJiYgIXRoaXMub3B0aW9ucy5hbHdheXNfc2hvd19kYXlzICYmIHJlbWFpbmluZy5kZCA9PT0gJzAnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pdGVtX2RkLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VwYXJhdG9yX2RkLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGF5c1Zpc2libGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFVwZGF0ZSBjb3VudGRvd24gdmFsdWVzLlxuICAgICAgICAgICAgLy8gVXNlIGB0cmltYCB0byBjb252ZXJ0IHNwYWNlcyB0byBlbXB0eSBzdHJpbmcgd2hlbiB0aGVyZSBhcmUgbm8gbGVhZGluZyB6ZXJvcy5cbiAgICAgICAgICAgIHRoaXMucmVtYWluaW5nX2RkLnRleHQocmVtYWluaW5nLmRkKTtcbiAgICAgICAgICAgIHRoaXMucmVtYWluaW5nX2hoMS50ZXh0KHJlbWFpbmluZy5oaFswXS50cmltKCkpO1xuICAgICAgICAgICAgdGhpcy5yZW1haW5pbmdfaGgyLnRleHQocmVtYWluaW5nLmhoWzFdKTtcbiAgICAgICAgICAgIHRoaXMucmVtYWluaW5nX21tMS50ZXh0KHJlbWFpbmluZy5tbVswXS50cmltKCkpO1xuICAgICAgICAgICAgdGhpcy5yZW1haW5pbmdfbW0yLnRleHQocmVtYWluaW5nLm1tWzFdKTtcbiAgICAgICAgICAgIHRoaXMucmVtYWluaW5nX3NzMS50ZXh0KHJlbWFpbmluZy5zc1swXS50cmltKCkpO1xuICAgICAgICAgICAgdGhpcy5yZW1haW5pbmdfc3MyLnRleHQocmVtYWluaW5nLnNzWzFdKTtcbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICAkLmZuW3BsdWdpbk5hbWVdID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblxuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcblxuICAgICAgICAvLyBJZiB0aGUgZmlyc3QgcGFyYW1ldGVyIGlzIGFuIG9iamVjdCAob3B0aW9ucykgb3Igd2FzIG9taXR0ZWQsIGluc3RhbnRpYXRlIGEgbmV3IHBsdWdpbiBpbnN0YW5jZS5cbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICghJC5kYXRhKHRoaXMsICdwbHVnaW5fJyArIHBsdWdpbk5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICQuZGF0YSh0aGlzLCAncGx1Z2luXycgKyBwbHVnaW5OYW1lLCBuZXcgQ291bnREb3duKHRoaXMsIG9wdGlvbnMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFsbG93IGFueSBwdWJsaWMgZnVuY3Rpb24gKGkuZS4gYSBmdW5jdGlvbiB3aG9zZSBuYW1lIGlzbid0ICdpbml0JyBvciBkb2Vzbid0IHN0YXJ0IHdpdGggYW4gdW5kZXJzY29yZSlcbiAgICAgICAgLy8gdG8gYmUgY2FsbGVkIHZpYSB0aGUgalF1ZXJ5IHBsdWdpbiwgZS5nLiAkKGVsZW1lbnQpLmNvdW50RG93bignZnVuY3Rpb25OYW1lJywgYXJnMSwgYXJnMikuXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJyAmJiBvcHRpb25zWzBdICE9PSAnXycgJiYgb3B0aW9ucyAhPT0gJ2luaXQnKSB7XG5cbiAgICAgICAgICAgIC8vIENhY2hlIHRoZSBtZXRob2QgY2FsbCB0byBtYWtlIGl0IHBvc3NpYmxlIHRvIHJldHVybiBhIHZhbHVlLlxuICAgICAgICAgICAgdmFyIHJldHVybnM7XG5cbiAgICAgICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gJC5kYXRhKHRoaXMsICdwbHVnaW5fJyArIHBsdWdpbk5hbWUpO1xuXG4gICAgICAgICAgICAgICAgLy8gVGVzdHMgdGhhdCB0aGVyZSdzIGFscmVhZHkgYSBwbHVnaW4gaW5zdGFuY2UgYW5kIGNoZWNrcyB0aGF0IHRoZSByZXF1ZXN0ZWQgcHVibGljIG1ldGhvZCBleGlzdHMuXG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlIGluc3RhbmNlb2YgQ291bnREb3duICYmIHR5cGVvZiBpbnN0YW5jZVtvcHRpb25zXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBDYWxsIHRoZSBtZXRob2Qgb2Ygb3VyIHBsdWdpbiBpbnN0YW5jZSwgYW5kIHBhc3MgaXQgdGhlIHN1cHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJucyA9IGluc3RhbmNlW29wdGlvbnNdLmFwcGx5KGluc3RhbmNlLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzLCAxKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQWxsb3cgaW5zdGFuY2VzIHRvIGJlIGRlc3Ryb3llZCB2aWEgdGhlICdkZXN0cm95JyBtZXRob2QuXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMgPT09ICdkZXN0cm95Jykge1xuICAgICAgICAgICAgICAgICAgICAkLmRhdGEodGhpcywgJ3BsdWdpbl8nICsgcGx1Z2luTmFtZSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gSWYgdGhlIGVhcmxpZXIgY2FjaGVkIG1ldGhvZCBnaXZlcyBhIHZhbHVlIGJhY2sgcmV0dXJuIHRoZSB2YWx1ZSxcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSByZXR1cm4gdGhpcyB0byBwcmVzZXJ2ZSBjaGFpbmFiaWxpdHkuXG4gICAgICAgICAgICByZXR1cm4gcmV0dXJucyAhPT0gdW5kZWZpbmVkID8gcmV0dXJucyA6IHRoaXM7XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxufSkod2luZG93LmpRdWVyeSwgd2luZG93LCBkb2N1bWVudCk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vanF1ZXJ5LmNvdW50ZG93bi9qcXVlcnkuY291bnRkb3duLmpzXG4vLyBtb2R1bGUgaWQgPSAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }
/******/ ]);